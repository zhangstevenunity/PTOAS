func.func @vec_and_kernel_2d(%arg0: memref<1024x1024xi32, #pto.address_space<gm>>,
                             %arg1: memref<1024x1024xi32, #pto.address_space<gm>>,
                             %arg2: memref<1024x1024xi32, #pto.address_space<gm>>,
                             %arg3: index, %arg4: index)
  attributes {hacc.entry, pto.func_core_type = #pto.func_core_type<AIV>} {
  // ==========================================
  // 1. 计算内存偏移量 (32x32 tile)
  // ==========================================
  %c4096_i64 = arith.constant 4096 : i64
  %c0_i64 = arith.constant 0 : i64
  %0 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%arg3]
  %1 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%arg4]
  // ==========================================
  // 2. 创建 Subview (32x32 窗口)
  // ==========================================
  %subview = memref.subview %arg0[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>> to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  %subview_0 = memref.subview %arg1[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>> to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  %subview_1 = memref.subview %arg2[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>> to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  // ==========================================
  // 3. Assign pointer (UB: 32x32 = 1024 elements)
  // ==========================================
  %2 = pto.pointer_cast(%c0_i64) : memref<1024xi32, #pto.address_space<ub>>
  %3 = pto.pointer_cast(%c4096_i64) : memref<1024xi32, #pto.address_space<ub>>
  %4 = pto.pointer_cast(%c0_i64) : memref<1024xi32, #pto.address_space<ub>>
  // ==========================================
  // 4. DMA Load
  // ==========================================
  pto.tload ins(%subview : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
           outs(%2 : memref<1024xi32, #pto.address_space<ub>>)
  pto.tload ins(%subview_0 : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
           outs(%3 : memref<1024xi32, #pto.address_space<ub>>)
  // ==========================================
  // 5. Compute: elementwise bitwise AND
  // ==========================================
  pto.set_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  pto.tand ins(%2, %3 : memref<1024xi32, #pto.address_space<ub>>, memref<1024xi32, #pto.address_space<ub>>)
          outs(%4 : memref<1024xi32, #pto.address_space<ub>>)
  // ==========================================
  // 6. DMA Store
  // ==========================================
  pto.set_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.store_dps ins(%4 : memref<1024xi32, #pto.address_space<ub>>)
            outs(%subview_1 : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
  return
}

func.func @vec_abs_kernel_2d(%arg0: memref<1024x1024xi32, #pto.address_space<gm>>,
                             %arg1: memref<1024x1024xi32, #pto.address_space<gm>>,
                             %arg2: index, %arg3: index)
  attributes {hacc.entry, pto.func_core_type = #pto.func_core_type<AIV>} {
  // ==========================================
  // 1. 计算内存偏移量 (32x32 tile)
  // ==========================================
  %c4096_i64 = arith.constant 4096 : i64
  %c0_i64    = arith.constant 0 : i64
  %0 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%arg2]
  %1 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%arg3]
  // ==========================================
  // 2. 创建 Subview (32x32 窗口)
  // ==========================================
  %subview_in = memref.subview %arg0[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>>
      to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  %subview_out = memref.subview %arg1[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>>
      to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  // ==========================================
  // 3. Assign pointer (UB: 32x32 = 1024 elements)
  // ==========================================
  %ub_in  = pto.pointer_cast(%c0_i64)    : memref<1024xi32, #pto.address_space<ub>>
  %ub_out = pto.pointer_cast(%c4096_i64) : memref<1024xi32, #pto.address_space<ub>>
  // ==========================================
  // 4. DMA Load
  // ==========================================
  pto.tload ins(%subview_in
      : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
    outs(%ub_in : memref<1024xi32, #pto.address_space<ub>>)
  // ==========================================
  // 5. Compute: elementwise ABS (pto.tabs)
  // ==========================================
  pto.set_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  pto.tabs_dps ins(%ub_in : memref<1024xi32, #pto.address_space<ub>>)
          outs(%ub_out : memref<1024xi32, #pto.address_space<ub>>)
  // ==========================================
  // 6. DMA Store
  // ==========================================
  pto.set_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.store_dps ins(%ub_out : memref<1024xi32, #pto.address_space<ub>>)
    outs(%subview_out
      : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
  return
}

func.func @vec_add_kernel_2d(%arg0: memref<1024x1024xi32, #pto.address_space<gm>>,
                             %arg1: memref<1024x1024xi32, #pto.address_space<gm>>,
                             %arg2: memref<1024x1024xi32, #pto.address_space<gm>>,
                             %arg3: index, %arg4: index)
  attributes {hacc.entry, pto.func_core_type = #pto.func_core_type<AIV>} {
  // ==========================================
  // 1. 计算内存偏移量 (32x32 tile)
  // ==========================================
  %c4096_i64 = arith.constant 4096 : i64
  %c0_i64 = arith.constant 0 : i64
  %0 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%arg3]
  %1 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%arg4]
  // ==========================================
  // 2. 创建 Subview (32x 窗口)
  // ==========================================
  %subview = memref.subview %arg0[%0, %1] [32,32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>> to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  %subview_0 = memref.subview %arg1[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>> to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  %subview_1 = memref.subview %arg2[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>> to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  // ==========================================
  // 3. Assign pointer (UB: 32x32 = 1024 elements)
  // ==========================================
  %2 = pto.pointer_cast(%c0_i64)    : memref<1024xi32, #pto.address_space<ub>>
  %3 = pto.pointer_cast(%c4096_i64) : memref<1024xi32, #pto.address_space<ub>>
  %4 = pto.pointer_cast(%c0_i64)    : memref<1024xi32, #pto.address_space<ub>>
  // ==========================================
  // 4. DMA Load
  // ==========================================
  pto.tload ins(%subview : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
               outs(%2 : memref<1024xi32, #pto.address_space<ub>>)
  pto.tload ins(%subview_0 : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
               outs(%3 : memref<1024xi32, #pto.address_space<ub>>)
  // ==========================================
  // 5. Compute: elementwise ADD (pto.tadd)
  // ==========================================
  pto.set_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  pto.tadd ins(%2, %3 : memref<1024xi32, #pto.address_space<ub>>, memref<1024xi32, #pto.address_space<ub>>)
          outs(%4 : memref<1024xi32, #pto.address_space<ub>>)
  // ==========================================
  // 6. DMA Store
  // ==========================================
  pto.set_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.store_dps ins(%4 : memref<1024xi32, #pto.address_space<ub>>)
    outs(%subview_1 : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
  return
}

func.func @vec_addc_kernel_2d(%arg0: memref<1024x1024xi32, #pto.address_space<gm>>,
                              %arg1: memref<1024x1024xi32, #pto.address_space<gm>>,
                              %arg2: memref<1024x1024xi32, #pto.address_space<gm>>,
                              %arg3: memref<1024x1024xi32, #pto.address_space<gm>>,
                              %arg4: index, %arg5: index)
  attributes {hacc.entry, pto.func_core_type = #pto.func_core_type<AIV>} {
  // ==========================================
  // 1. 计算内存偏移量 (32x32 tile)
  // ==========================================
  %c4096_i64 = arith.constant 4096 : i64
  %c8192_i64 = arith.constant 8192 : i64
  %c0_i64    = arith.constant 0 : i64
  %0 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%arg4]
  %1 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%arg5]
  // ==========================================
  // 2. 创建 Subview (32x32 窗口)
  // ==========================================
  %subview0 = memref.subview %arg0[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>>
      to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  %subview1 = memref.subview %arg1[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>>
      to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  %subview2 = memref.subview %arg2[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>>
      to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  %subview_out = memref.subview %arg3[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>>
      to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  // ==========================================
  // 3. Assign pointer (UB: 32x32 = 1024 elements)
  //     inputs + 1 output
  // ==========================================
  %ub0  = pto.pointer_cast(%c0_i64)    : memref<1024xi32, #pto.address_space<ub>>
  %ub1  = pto.pointer_cast(%c4096_i64) : memref<1024xi32, #pto.address_space<ub>>
  %ub2  = pto.pointer_cast(%c8192_i64) : memref<1024xi32, #pto.address_space<ub>>
  %ubout = pto.pointer_cast(%c0_i64)   : memref<1024xi32, #pto.address_space<ub>>
  // ==========================================
  // 4. DMA Load
  // ==========================================
  pto.tload ins(%subview0 : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
               outs(%ub0 : memref<1024xi32, #pto.address_space<ub>>)
  pto.tload ins(%subview1 : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
               outs(%ub1 : memref<1024xi32, #pto.address_space<ub>>)
  pto.tload ins(%subview2 : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
               outs(%ub2 : memref<1024xi32, #pto.address_space<ub>>)
  // ==========================================
  // 5. Compute: elementwise ternary add (src0 + src1 + src2)
  // ==========================================
  pto.set_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  pto.taddc ins(%ub0, %ub1, %ub2
        : memref<1024xi32, #pto.address_space<ub>>,
          memref<1024xi32, #pto.address_space<ub>>,
          memref<1024xi32, #pto.address_space<ub>>)
        outs(%ubout : memref<1024xi32, #pto.address_space<ub>>)
  // ==========================================
  // 6. DMA Store
  // ==========================================
  pto.set_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.store_dps ins(%ubout : memref<1024xi32, #pto.address_space<ub>>)
    outs(%subview_out : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
  return
}
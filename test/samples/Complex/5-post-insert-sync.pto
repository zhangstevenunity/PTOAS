func.func @tci_kernel_2d(
    %out: memref<1024x1024xi32, #pto.address_space<gm>>,
    %tile_i: index, %tile_j: index,
    %S: i32)
  attributes {hacc.entry, pto.func_core_type = #pto.func_core_type<AIV>} {
  // ==========================================
  // 1) 计算 tile 起始坐标 (32x32 tile)
  // ==========================================
  %c0_i64 = arith.constant 0 : i64
  %0 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%tile_i]
  %1 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%tile_j]
  // ==========================================
  // 2) 创建 GM 输出 subview (32x32 窗口)
  // ==========================================
  %out_subview = memref.subview %out[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>>
      to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  // ==========================================
  // 3) Assign pointer: UB dst tile (32x32 = 1024 elements)
  // ==========================================
  %ub_dst = pto.pointer_cast(%c0_i64) : memref<1024xi32, #pto.address_space<ub>>
  // ==========================================
  // 4) Compute: Generate contiguous integer sequence into dst tile
  //    线性 k: dst(k) = S + k (默认升序)
  // ==========================================
  pto.tci ins(%S : i32)
          outs(%ub_dst : memref<1024xi32, #pto.address_space<ub>>)
  // ==========================================
  // 5) DMA Store: UB -> GM
  // ==========================================
  pto.set_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.store_dps ins(%ub_dst : memref<1024xi32, #pto.address_space<ub>>)
            outs(%out_subview : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
  return
}
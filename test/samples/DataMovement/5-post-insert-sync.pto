
func.func @test_textract_dps_2d(%arg0: memref<1024x1024xi32, #pto.address_space<gm>>,
                                %arg1: memref<1024x1024xi32, #pto.address_space<gm>>,
                                %arg2: index, %arg3: index,
                                %arg4: index, %arg5: index)
  attributes {hacc.entry, pto.func_core_type = #pto.func_core_type<AIV>} {
  // =========================================================
  // 1) Global tile base offset (32x32 tile in GM)
  //    tileRow = %arg2, tileCol = %arg3
  // =========================================================
  %c0_i64 = arith.constant 0 : i64
  %0 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%arg2]
  %1 = affine.apply affine_map<()[s0] -> (s0 * 32)>()[%arg3]
  // =========================================================
  // 2) Subview a 32x32 source tile and a 16x16 destination tile in GM
  // =========================================================
  %src_gm = memref.subview %arg0[%0, %1] [32, 32] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>>
      to memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  // Write the extracted 16x16 result back to GM at the same tile origin
  // (you can change this to any output location you want).
  %dst_gm = memref.subview %arg1[%0, %1] [16, 16] [1, 1]
    : memref<1024x1024xi32, #pto.address_space<gm>>
      to memref<16x16xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>
  // =========================================================
  // 3) UB buffers: src tile (32x32=1024 elems) and dst tile (16x16=256 elems)
  // =========================================================
  %ub_src = pto.pointer_cast(%c0_i64) : memref<32x32xi32, #pto.address_space<ub>>
  %ub_dst = pto.pointer_cast(%c0_i64) : memref<16x16xi32, #pto.address_space<ub>>
  // =========================================================
  // 4) DMA load 32x32 src tile into UB
  // =========================================================
  pto.tload ins(%src_gm : memref<32x32xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
           outs(%ub_src : memref<32x32xi32, #pto.address_space<ub>>)
  // =========================================================
  // 5) Compute: textract_dps (extract 16x16 window from 32x32 UB tile)
  //    %arg4 = indexRow, %arg5 = indexCol  (typically 0..(32-16))
  // =========================================================
  pto.set_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  pto.textract_dps ins(%ub_src : memref<32x32xi32, #pto.address_space<ub>>,
                       %arg4 : index, %arg5 : index)
               outs(%ub_dst : memref<16x16xi32, #pto.address_space<ub>>)
  // =========================================================
  // 6) DMA store extracted 16x16 tile back to GM
  // =========================================================
  pto.set_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.wait_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  pto.store_dps ins(%ub_dst : memref<16x16xi32, #pto.address_space<ub>>)
            outs(%dst_gm : memref<16x16xi32, strided<[1024, 1], offset: ?>, #pto.address_space<gm>>)
  return
}
// RUN: ./bin/ptoas --enable-insert-sync %s 2>&1 1>/dev/null | FileCheck %s

module {
  // CHECK-LABEL: func.func @test_loop_nest_sync
  // CHECK: scf.for
  // CHECK: scf.for
  // CHECK: pto.load_dps
  // CHECK: pto.set_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  // CHECK: pto.wait_flag[<PIPE_MTE2>, <PIPE_V>, <EVENT_ID0>]
  // CHECK: scf.if
  // CHECK: pto.addf_dps
  // CHECK: pto.set_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  // CHECK: } else {
  // CHECK: pto.set_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  // CHECK: pto.wait_flag[<PIPE_V>, <PIPE_MTE3>, <EVENT_ID0>]
  // CHECK: pto.store_dps
  // CHECK: pto.barrier <PIPE_ALL>
  func.func @test_loop_nest_sync(%arg0: memref<16x16x16xf16, #pto.address_space<gm>>,
                                 %arg1: memref<16x16x16xf16, #pto.address_space<gm>>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %ub = memref.alloc() : memref<16x16x16xf16, #pto.address_space<vec>>
    scf.for %i = %c0 to %c2 step %c1 {
      scf.for %j = %c0 to %c2 step %c1 {
        pto.load_dps ins(%arg0 : memref<16x16x16xf16, #pto.address_space<gm>>)
                     outs(%ub : memref<16x16x16xf16, #pto.address_space<vec>>)
        %cond = arith.cmpi eq, %j, %c0 : index
        scf.if %cond {
          pto.addf_dps ins(%ub, %ub : memref<16x16x16xf16, #pto.address_space<vec>>,
                                      memref<16x16x16xf16, #pto.address_space<vec>>)
                       outs(%ub : memref<16x16x16xf16, #pto.address_space<vec>>)
        }
        pto.store_dps ins(%ub : memref<16x16x16xf16, #pto.address_space<vec>>)
                      outs(%arg1 : memref<16x16x16xf16, #pto.address_space<gm>>)
      }
    }
    return
  }
}

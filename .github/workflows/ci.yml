name: CI

on:
  push:
  pull_request:
  # Nightly remote-board validation (GitHub cron is UTC).
  # 22:00 CST (UTC+8) == 14:00 UTC.
  schedule:
    - cron: "0 14 * * *"
  workflow_dispatch:
    inputs:
      stage:
        description: "Validation stage (build|run)"
        type: choice
        options: [build, run]
        default: run
      run_mode:
        description: "Run mode passed to generated CMake (sim|npu)"
        type: choice
        options: [npu, sim]
        default: npu
      soc_version:
        description: "Ascend SoC version (e.g. Ascend910B1)"
        type: string
        default: Ascend910
      device_id:
        description: "aclrtSetDevice device id"
        type: string
        # NOTE: On our shared remote NPU host, device 0/1 may be unstable or
        # occupied. Default to a higher id to reduce flakiness for scheduled
        # runs. Override in workflow_dispatch if needed.
        default: "2"
      skip_cases:
        description: "Comma/space separated testcase names to skip (e.g. scatter,mrgsort)"
        type: string
        default: "mix_kernel,vadd_validshape,vadd_validshape_dynamic"
      run_only_cases:
        description: "Comma/space separated testcase names to run (empty = run all)"
        type: string
        default: ""
      pto_isa_repo:
        description: "pto-isa repo URL on remote"
        type: string
        default: https://gitcode.com/cann/pto-isa.git
      pto_isa_commit:
        description: "pto-isa ref (commit/tag/branch; empty = default branch)"
        type: string
        # NOTE: Remote NPU validation depends on upstream pto-isa. Pin a known-good
        # commit by default to keep scheduled runs deterministic.
        default: 082b94a3d2eaa17d63d1e5b0d74714a00594ace0
      remote_host:
        description: "SSH host/IP for the NPU machine"
        type: string
        default: 101.245.68.6
      remote_user:
        description: "SSH user for the NPU machine"
        type: string
        default: zhongxuan
      remote_port:
        description: "SSH port"
        type: string
        default: "22"

permissions:
  contents: read
  actions: write

jobs:
  build-cli-prebuilt:
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    runs-on: ubuntu-22.04
    env:
      LLVM_VER: 19.1.7
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name || github.repository }}
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 1
          persist-credentials: false

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            cmake git ninja-build \
            clang lld \
            libedit-dev zlib1g-dev libxml2-dev libzstd-dev \
            xz-utils

      - name: Restore prebuilt LLVM cache
        id: cache-llvm-prebuilt
        uses: actions/cache/restore@v4
        with:
          path: llvm-prebuilt
          key: llvm-prebuilt-${{ runner.os }}-${{ env.LLVM_VER }}-Linux-X64

      - name: Download prebuilt LLVM (cache miss)
        if: steps.cache-llvm-prebuilt.outputs.cache-hit != 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p llvm-prebuilt
          cd llvm-prebuilt
          curl -L -o "LLVM-${LLVM_VER}-Linux-X64.tar.xz" \
            "https://github.com/llvm/llvm-project/releases/download/llvmorg-${LLVM_VER}/LLVM-${LLVM_VER}-Linux-X64.tar.xz"
          tar -xJf "LLVM-${LLVM_VER}-Linux-X64.tar.xz"

      - name: Save prebuilt LLVM cache
        if: steps.cache-llvm-prebuilt.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: llvm-prebuilt
          key: llvm-prebuilt-${{ runner.os }}-${{ env.LLVM_VER }}-Linux-X64

      - name: Define LLVM paths
        shell: bash
        run: |
          set -euo pipefail
          echo "LLVM_INSTALL_DIR=${GITHUB_WORKSPACE}/llvm-prebuilt/LLVM-${LLVM_VER}-Linux-X64" >> "${GITHUB_ENV}"

      - name: Verify LLVM install
        shell: bash
        run: |
          set -euo pipefail
          "${LLVM_INSTALL_DIR}/bin/llvm-config" --version
          "${LLVM_INSTALL_DIR}/bin/llvm-config" --shared-mode
          if [[ -x "${LLVM_INSTALL_DIR}/bin/clang++" ]]; then
            "${LLVM_INSTALL_DIR}/bin/clang++" --version
          fi
          if [[ -x "${LLVM_INSTALL_DIR}/bin/ld.lld" ]]; then
            "${LLVM_INSTALL_DIR}/bin/ld.lld" --version
          fi

      - name: Build PTOAS (no Python bindings)
        shell: bash
        run: |
          set -euo pipefail
          export PATH="${LLVM_INSTALL_DIR}/bin:${PATH}"
          # Prefer clang/lld from the downloaded LLVM distribution to ensure it
          # can link LLVM's static archives (may contain LTO bitcode).
          CC="${LLVM_INSTALL_DIR}/bin/clang"
          CXX="${LLVM_INSTALL_DIR}/bin/clang++"
          if [[ ! -x "${CC}" || ! -x "${CXX}" ]]; then
            CC=clang
            CXX=clang++
          fi
          cmake -G Ninja -S . -B build \
            -DCMAKE_C_COMPILER="${CC}" \
            -DCMAKE_CXX_COMPILER="${CXX}" \
            -DCMAKE_EXE_LINKER_FLAGS="-fuse-ld=lld" \
            -DCMAKE_SHARED_LINKER_FLAGS="-fuse-ld=lld" \
            -DCMAKE_MODULE_LINKER_FLAGS="-fuse-ld=lld" \
            -DBUILD_SHARED_LIBS=OFF \
            -DPTO_ENABLE_PYTHON_BINDING=OFF \
            -DLLVM_DIR="${LLVM_INSTALL_DIR}/lib/cmake/llvm" \
            -DMLIR_DIR="${LLVM_INSTALL_DIR}/lib/cmake/mlir" \
            -DCMAKE_BUILD_TYPE=Release
          ninja -C build pto-opt
          ./build/tools/ptoas/ptoas --version

      - name: Run smoke tests (.pto -> .cpp)
        shell: bash
        env:
          PTOAS_BIN: ${{ github.workspace }}/build/tools/ptoas/ptoas
        run: |
          set -euo pipefail
          out="${RUNNER_TEMP:-${GITHUB_WORKSPACE}/.tmp}/ptoas_out"
          rm -rf "${out}"
          mkdir -p "${out}"
          for f in test/samples/InjectSync/*.pto; do
            base="$(basename "$f" .pto)"
            "${PTOAS_BIN}" "$f" --enable-insert-sync -o "${out}/${base}.cpp"
          done

  build-and-test:
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule'
    runs-on: ubuntu-22.04
    env:
      LLVM_VER: 19.1.7
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name || github.repository }}
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 1
          persist-credentials: false

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            cmake git ninja-build \
            clang lld \
            libedit-dev zlib1g-dev libxml2-dev libzstd-dev \
            xz-utils

      - name: Define payload paths
        shell: bash
        run: |
          set -euo pipefail
          # NOTE: Some GitHub/GHES versions don't allow using `${{ runner.temp }}` in
          # `jobs.<job>.env`. Use the runtime env var instead.
          tmp_root="${RUNNER_TEMP:-${GITHUB_WORKSPACE}/.tmp}"
          echo "PAYLOAD_DIR=${tmp_root}/ptoas_payload" >> "${GITHUB_ENV}"
          echo "PAYLOAD_TGZ=${tmp_root}/ptoas_payload.tgz" >> "${GITHUB_ENV}"

      - name: Prepare payload dir
        shell: bash
        run: |
          set -euo pipefail
          rm -rf "${PAYLOAD_DIR}" "${PAYLOAD_TGZ}"
          mkdir -p "${PAYLOAD_DIR}/test/samples"
          mkdir -p "${PAYLOAD_DIR}/test/npu_validation/scripts"
          mkdir -p "${PAYLOAD_DIR}/test/npu_validation/templates"

      - name: Restore prebuilt LLVM cache
        id: cache-llvm-prebuilt
        uses: actions/cache/restore@v4
        with:
          path: llvm-prebuilt
          key: llvm-prebuilt-${{ runner.os }}-${{ env.LLVM_VER }}-Linux-X64

      - name: Download prebuilt LLVM (cache miss)
        if: steps.cache-llvm-prebuilt.outputs.cache-hit != 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p llvm-prebuilt
          cd llvm-prebuilt
          curl -L -o "LLVM-${LLVM_VER}-Linux-X64.tar.xz" \
            "https://github.com/llvm/llvm-project/releases/download/llvmorg-${LLVM_VER}/LLVM-${LLVM_VER}-Linux-X64.tar.xz"
          tar -xJf "LLVM-${LLVM_VER}-Linux-X64.tar.xz"

      - name: Save prebuilt LLVM cache
        if: steps.cache-llvm-prebuilt.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: llvm-prebuilt
          key: llvm-prebuilt-${{ runner.os }}-${{ env.LLVM_VER }}-Linux-X64

      - name: Define LLVM paths
        shell: bash
        run: |
          set -euo pipefail
          echo "LLVM_INSTALL_DIR=${GITHUB_WORKSPACE}/llvm-prebuilt/LLVM-${LLVM_VER}-Linux-X64" >> "${GITHUB_ENV}"

      - name: Build PTOAS
        shell: bash
        env:
          PTOAS_BIN: ${{ github.workspace }}/build/tools/ptoas/ptoas
        run: |
          set -euo pipefail
          export PATH="${LLVM_INSTALL_DIR}/bin:${PATH}"
          # Prefer clang/lld from the downloaded LLVM distribution to ensure it
          # can link LLVM's static archives (may contain LTO bitcode).
          CC="${LLVM_INSTALL_DIR}/bin/clang"
          CXX="${LLVM_INSTALL_DIR}/bin/clang++"
          if [[ ! -x "${CC}" || ! -x "${CXX}" ]]; then
            CC=clang
            CXX=clang++
          fi
          cmake -G Ninja -S . -B build \
            -DCMAKE_C_COMPILER="${CC}" \
            -DCMAKE_CXX_COMPILER="${CXX}" \
            -DCMAKE_EXE_LINKER_FLAGS="-fuse-ld=lld" \
            -DCMAKE_SHARED_LINKER_FLAGS="-fuse-ld=lld" \
            -DCMAKE_MODULE_LINKER_FLAGS="-fuse-ld=lld" \
            -DBUILD_SHARED_LIBS=OFF \
            -DPTO_ENABLE_PYTHON_BINDING=OFF \
            -DLLVM_DIR="${LLVM_INSTALL_DIR}/lib/cmake/llvm" \
            -DMLIR_DIR="${LLVM_INSTALL_DIR}/lib/cmake/mlir" \
            -DCMAKE_BUILD_TYPE=Release
          ninja -C build pto-opt
          "${PTOAS_BIN}" --version

          # Generate payload C++ kernels from existing .pto samples (no MLIR Python bindings required).
          out_root="${PAYLOAD_DIR}/test/samples"
          tmp_log="$(mktemp -t ptoas.pto2cpp.XXXXXX)"
          for d in ControlFlow FFN FlashAttention GQA InjectSync MatmulVectorMix Partition5D; do
            for f in "test/samples/${d}"/*.pto; do
              [[ -f "$f" ]] || continue
              base="$(basename "$f" .pto)"
              mkdir -p "${out_root}/${d}"
              cpp="${out_root}/${d}/${base}-pto.cpp"
              if ! "${PTOAS_BIN}" "$f" --enable-insert-sync -o "$cpp" >"$tmp_log" 2>&1; then
                echo "ERROR: ptoas failed for ${f}"
                cat "$tmp_log"
                exit 1
              fi
            done
          done
          rm -f "$tmp_log"
          count="$(find "${out_root}" -type f -name '*-pto.cpp' | wc -l | tr -d ' ')"
          echo "Generated ${count} kernel(s) into ${out_root}"
          [[ "${count}" -gt 0 ]]

      - name: Build payload artifact
        if: >-
          ${{
            github.event_name == 'workflow_dispatch' ||
            github.event_name == 'schedule'
          }}
        shell: bash
        run: |
          set -euo pipefail
          cp test/npu_validation/scripts/generate_testcase.py "${PAYLOAD_DIR}/test/npu_validation/scripts/"
          cp test/npu_validation/scripts/run_remote_npu_validation.sh "${PAYLOAD_DIR}/test/npu_validation/scripts/"
          cp test/npu_validation/templates/* "${PAYLOAD_DIR}/test/npu_validation/templates/"
          chmod +x "${PAYLOAD_DIR}/test/npu_validation/scripts/run_remote_npu_validation.sh"
          tar -czf "${PAYLOAD_TGZ}" -C "${PAYLOAD_DIR}" .

      - name: Upload payload artifact
        if: >-
          ${{
            github.event_name == 'workflow_dispatch' ||
            github.event_name == 'schedule'
          }}
        uses: actions/upload-artifact@v4
        with:
          name: ptoas_payload
          path: ${{ env.PAYLOAD_TGZ }}
          if-no-files-found: error

  remote-npu-validation:
    needs: build-and-test
    runs-on: ubuntu-22.04
    timeout-minutes: 180
    concurrency:
      group: remote-npu-validation
      cancel-in-progress: false
    # Ordering: `needs: build-and-test` enforces "CI -> remote".
    if: >-
      ${{
        (github.event_name == 'workflow_dispatch' ||
         github.event_name == 'schedule')
      }}
    env:
      PAYLOAD_DOWNLOAD_DIR: ${{ github.workspace }}/_payload
      PAYLOAD_TGZ: ${{ github.workspace }}/_payload/ptoas_payload.tgz
      # Temporary CI gate: skip cases that still error/flap on the remote NPU.
      # Update this list as we fix the underlying issues.
      DEFAULT_SKIP_CASES: >-
        mix_kernel,vadd_validshape,vadd_validshape_dynamic
      # Keep nightly runs deterministic by pinning pto-isa unless overridden.
      DEFAULT_PTO_ISA_COMMIT: 082b94a3d2eaa17d63d1e5b0d74714a00594ace0
    steps:
      - name: Resolve validation parameters
        shell: bash
        env:
          STAGE: ${{ github.event.inputs.stage || 'run' }}
          RUN_MODE: ${{ github.event.inputs.run_mode || 'npu' }}
          SOC_VERSION: ${{ github.event.inputs.soc_version || 'Ascend910' }}
          DEVICE_ID: ${{ github.event.inputs.device_id || '2' }}
          SKIP_CASES: ${{ github.event.inputs.skip_cases || '' }}
          RUN_ONLY_CASES: ${{ github.event.inputs.run_only_cases || '' }}
          PTO_ISA_REPO: ${{ github.event.inputs.pto_isa_repo || 'https://gitcode.com/cann/pto-isa.git' }}
          PTO_ISA_COMMIT: ${{ github.event.inputs.pto_isa_commit || '' }}
          REMOTE_HOST: ${{ github.event.inputs.remote_host || '101.245.68.6' }}
          REMOTE_USER: ${{ github.event.inputs.remote_user || 'zhongxuan' }}
          REMOTE_PORT: ${{ github.event.inputs.remote_port || '22' }}
        run: |
          set -euo pipefail
          # For scheduled runs, default to DEFAULT_SKIP_CASES (known-bad/flaky).
          # For workflow_dispatch runs, honor the user's input (the UI default
          # is pre-filled but can be edited to run everything).
          if [[ "${GITHUB_EVENT_NAME}" != "workflow_dispatch" ]]; then
            if [[ -z "${SKIP_CASES}" ]]; then
              SKIP_CASES="${DEFAULT_SKIP_CASES}"
            fi
            if [[ -z "${PTO_ISA_COMMIT}" ]]; then
              PTO_ISA_COMMIT="${DEFAULT_PTO_ISA_COMMIT}"
            fi
          fi
          echo "STAGE=${STAGE}" >> "${GITHUB_ENV}"
          echo "RUN_MODE=${RUN_MODE}" >> "${GITHUB_ENV}"
          echo "SOC_VERSION=${SOC_VERSION}" >> "${GITHUB_ENV}"
          echo "DEVICE_ID=${DEVICE_ID}" >> "${GITHUB_ENV}"
          echo "SKIP_CASES=${SKIP_CASES}" >> "${GITHUB_ENV}"
          echo "RUN_ONLY_CASES=${RUN_ONLY_CASES}" >> "${GITHUB_ENV}"
          echo "PTO_ISA_REPO=${PTO_ISA_REPO}" >> "${GITHUB_ENV}"
          echo "PTO_ISA_COMMIT=${PTO_ISA_COMMIT}" >> "${GITHUB_ENV}"
          echo "REMOTE_HOST=${REMOTE_HOST}" >> "${GITHUB_ENV}"
          echo "REMOTE_USER=${REMOTE_USER}" >> "${GITHUB_ENV}"
          echo "REMOTE_PORT=${REMOTE_PORT}" >> "${GITHUB_ENV}"

      - name: Setup SSH
        shell: bash
        env:
          SSH_KEY: ${{ secrets.SSH_KEY }}
          SSH_KNOWN_HOSTS: ${{ secrets.SSH_KNOWN_HOSTS }}
        run: |
          set -euo pipefail
          if [[ -z "${SSH_KEY}" ]]; then
            echo "ERROR: secrets.SSH_KEY is not set"
            exit 1
          fi
          if [[ -z "${SSH_KNOWN_HOSTS}" ]]; then
            echo "ERROR: secrets.SSH_KNOWN_HOSTS is not set"
            exit 1
          fi

          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          printf '%s\n' "${SSH_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          printf '%s\n' "${SSH_KNOWN_HOSTS}" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Download payload artifact
        uses: actions/download-artifact@v4
        with:
          name: ptoas_payload
          path: ${{ env.PAYLOAD_DOWNLOAD_DIR }}

      - name: Copy payload to remote
        shell: bash
        run: |
          set -euo pipefail
          if [[ ! -f "${PAYLOAD_TGZ}" ]]; then
            echo "ERROR: payload tarball not found: ${PAYLOAD_TGZ}"
            exit 1
          fi
          REMOTE_DIR="/tmp/ptoas_npu_validation/${GITHUB_REPOSITORY}/${GITHUB_RUN_ID}"
          echo "REMOTE_DIR=${REMOTE_DIR}" >> "${GITHUB_ENV}"
          ssh -p "${REMOTE_PORT}" "${REMOTE_USER}@${REMOTE_HOST}" "rm -rf '${REMOTE_DIR}' && mkdir -p '${REMOTE_DIR}'"
          scp -P "${REMOTE_PORT}" "${PAYLOAD_TGZ}" "${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_DIR}/payload.tgz"

      - name: Run remote validation
        shell: bash
        run: |
          set -euo pipefail
          ssh -p "${REMOTE_PORT}" "${REMOTE_USER}@${REMOTE_HOST}" \
            "set -euo pipefail; \
             cd '${REMOTE_DIR}'; \
             tar -xzf payload.tgz; \
             STAGE='${STAGE}' RUN_MODE='${RUN_MODE}' SOC_VERSION='${SOC_VERSION}' PTO_ISA_REPO='${PTO_ISA_REPO}' PTO_ISA_COMMIT='${PTO_ISA_COMMIT}' DEVICE_ID='${DEVICE_ID}' SKIP_CASES='${SKIP_CASES}' RUN_ONLY_CASES='${RUN_ONLY_CASES}' \
               bash ./test/npu_validation/scripts/run_remote_npu_validation.sh"

      - name: Fetch results
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${REMOTE_DIR:-}" ]]; then
            echo "REMOTE_DIR is not set; skipping results fetch."
            exit 0
          fi
          scp -P "${REMOTE_PORT}" "${REMOTE_USER}@${REMOTE_HOST}:${REMOTE_DIR}/remote_npu_validation_results.tsv" ./remote_npu_validation_results.tsv || true

      - name: Upload results artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: remote_npu_validation_results
          path: remote_npu_validation_results.tsv
          if-no-files-found: warn

      - name: Cleanup remote
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          if [[ -n "${REMOTE_DIR:-}" ]]; then
            ssh -p "${REMOTE_PORT}" "${REMOTE_USER}@${REMOTE_HOST}" "rm -rf '${REMOTE_DIR}'" || true
          fi
